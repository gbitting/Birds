import pandas as pd
import numpy as np

# 1
data = pd.read_csv("bird_jan25jan16.txt", sep=r"\s+", engine = 'python', parse_dates=[[0, 1]], names = ['date', 'time', 'count'])
birds = pd.DataFrame(data)

birds['date_time'] = pd.to_datetime(birds['date_time'])

# 2
birds['date_time'] = birds['date_time'].dt.tz_localize('UTC')
birds['date_time'] = birds['date_time'].dt.tz_convert('Europe/Stockholm')

birds = birds.set_index('date_time')

# 3
class preProcessing():     

    @staticmethod
    def incompleteCountFix(data):
        """Deals with incomplete counts by adding the snipped off parts
        back to the numbers."""
        dataVals = data.iloc[:, 0].to_numpy()
        for n in range(len(dataVals)-1):
            #Check that previous value is smaller than next
            #and that the next next is bigger or equal to the previous
            #in order to prevent picking up a reset
            if(dataVals[n] > dataVals[n+1] and dataVals[n+2]>=dataVals[n]):
                #Check for 0 case as below strategy doesn't work then
                if(dataVals[n+1]==0):
                    #If glitched number is 0 then the real number neighboring
                    #it should be divisible by 10
                    if(dataVals[n]%10==0):
                        dataVals[n+1]=dataVals[n]
                        continue
                    if(dataVals[n+2]%10==0):
                        dataVals[n+1]=dataVals[n+2]
                        continue
                    else:
                        continue
                #Get order of glitched number
                orderGlitched = int(np.floor(np.log10(dataVals[n+1])))
                #Create a new num.
                newNum=0
                #Strip the n'th number of the parts that the
                #n+1th number is not missing and add resulting number to newNum
                newNum+=(dataVals[n]//(10**(orderGlitched+1)))*(10**(orderGlitched+1))
                #Add the n+1th number to newnum to complete the number
                newNum+=dataVals[n+1]
                dataVals[n+1]=newNum
        data["count"] = dataVals
        return data
        
    @staticmethod
    def resetFix(data):
        """Deals with count resets by adding the number before the reset to
        all the following numbers."""
        dataVals = data.iloc[:, 0].to_numpy()
        for n in range(1, len(dataVals)-1):
            #Check if a value is 0 if so => reset
            #if value previous also 0 then adding it does nothing
            if(dataVals[-n-1]==0):
                #Add the previous count to all of the elements after
                dataVals[-n-1:] +=dataVals[-n-2]
        data["count"] = dataVals
        return data
    
    @staticmethod
    def orderFix(data):
        """Fixes the order of the dates. Some dates are out of order."""
        #Convert time to int. (Gives time in ns since 1970)
        dataTS = data.index.astype("int64")
        dataTS = dataTS.to_numpy()
        #Store count in np array for speed. (This will be done for all preProc funcs)
        dataVals = data.iloc[:, 0].to_numpy()
        #Sort both arrays from least to most.
        dataTS = np.sort(dataTS)
        dataVals = np.sort(dataVals)
        #Update count collumn
        data["count"] = dataVals
        #Translate dataTS into timestamps in our region
        dataTS = pd.to_datetime(dataTS)
        dataTS=dataTS.tz_localize('UTC')
        dataTS=dataTS.tz_convert('Europe/Stockholm')
        #Update time collumn
        data.index = (dataTS)
        return data
    
    @staticmethod
    def flutterErrorFix(data):
        """Deals with error from birds fluttering by the box by
        limiting counts to approx 8 per 2 minute."""
        dataVals = data.iloc[:, 0].to_numpy()
        for n in range(len(dataVals)-1):
            #Check for more than 8 counts in less than 2 min
            if(dataVals[n+1]-dataVals[n] > 8):
                #Add offset to take care of extra counts and add in 8
                #counts for all elements of index n+1 or higher.
                dataVals[n+1:]+=-(dataVals[n+1]-dataVals[n])+8
        data["count"] = dataVals
        return data
    
    @staticmethod
    def missingLineFix(data):
        """Fixes missing lines by adding line inbetween that is at half the time
        of the current line and next consecutive line, and which has the avg
        count between the current and next line."""
        #Convert time to int. (Gives time in ns since 1970)
        dataTS = data.index.astype("int64")
        dataTS = dataTS.to_numpy()
        dataVals = data.iloc[:, 0].to_numpy()
        for n in range (len(dataVals)):
            #Define variable to keep track of size of dataVals (and dataTS) as it increases
            k=0
            #Check if difference between current row and next is more than 2 min 30 sec
            #arbitrarily.
            if (dataTS[n+k+1] - dataTS[n+k])/10**9 > 150:
                #Create variable to store time that will be added in new row
                newTime = (dataTS[n+k]+dataTS[n+k+1])/2
                #Create new value that will be stored in row.
                newValue = np.ceil((dataVals[n+k+1] + dataVals[n+k])/2)
                #Add new time and values
                dataTS = np.insert(dataTS, n+k+1, newTime)
                dataVals = np.insert(dataVals, n+k+1, newValue)
                #Increase index k                k+=1
        #Resize dataframe to fit in new size collumns.
        data = pd.concat([data, pd.DataFrame([{}]*(len(dataVals)-len(data.index)))], ignore_index=True)
        #Update count collumn
        data["count"] = dataVals
        #Translate dataTS into timestamps in our region
        dataTS = pd.to_datetime(dataTS)
        dataTS=dataTS.tz_localize('UTC')
        dataTS=dataTS.tz_convert('Europe/Stockholm')
        #Update time collumn
        data.index = (dataTS)
        return data
            
    @staticmethod
    def process(data):
        """Calls all functions related to preProcessing for the document and outputs result in a csv file.
        Do not change the order of the calls. Preprocessing may break as
        a result."""
        #IncompleteCountFix should always be called first
        #as it relies on the fact that an incomplete number
        #will be of, at least, one order less than it's complete
        #neighbors. If resets are fixed first this is not the case
        data=preProcessing.incompleteCountFix(data)
        data=preProcessing.resetFix(data)
        data=preProcessing.orderFix(data)
        data=preProcessing.flutterErrorFix(data)
        data=preProcessing.missingLineFix(data)
        data.to_csv("ProcessedBirdData.csv", sep="\t", encoding="utf-8")
        return data

birds = preProcessing.process(birds)
print(birds)
