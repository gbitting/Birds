import pandas as pd
import numpy as np

# 1
data = pd.read_csv("bird_jan25jan16.txt", sep=r"\s+", engine = 'python', parse_dates=[[0, 1]], names = ['date', 'time', 'count'])
birds = pd.DataFrame(data)

# 2
birds['date_time'] = birds['date_time'].dt.tz_localize('UTC')
birds['date_time'] = birds['date_time'].dt.tz_convert('Europe/Stockholm')

birds = birds.set_index('date_time')

# 3
class preProcessing():     

    @staticmethod
    def doubleDateFix(data):
        """Some dates are double and out of order. This function removes these dates."""
        #Convert time to int. (Gives time in ns since 1970)
        dataTS = data.index.astype("int64")
        dataVals = data.iloc[:, 0].to_numpy()
        #New variable to offset dataTS and dataVals
        k=0
        #Check for dates out of place
        for n in range(1, len(dataTS)-1):
            if dataTS[n-k] < dataTS[n-k-1] or dataTS[n-k]>dataTS[n-k+1]:
                #Remove out of place dates and their counts.
                dataTS = np.delete(dataTS, n-k)
                dataVals = np.delete(dataVals, n-k)
                k+=1
        #Convert dataTS back to datetime
        dataTS = pd.to_datetime(dataTS)
        dataTS=dataTS.tz_localize('UTC')
        dataTS=dataTS.tz_convert('Europe/Stockholm')
        #Create new pandas dataframe with new collumns.
        data = pd.DataFrame(data={'count':dataVals, 'date_time':dataTS})
        data = data.set_index('date_time')
        return data    

    @staticmethod
    def incompleteCountFix(data):
        """Deals with incomplete counts by replacing them with their full counterpart."""
        dataVals = data.iloc[:, 0].to_numpy()
        #Convert dataVals numbers to string
        dataVals = np.char.mod('%s', dataVals)
        for n in range(len(dataVals)-2):
            if len(dataVals[n]) > len(dataVals[n+1]):
                #Check if the number is equal to its neighbors end
                if(dataVals[n][len(dataVals[n])-len(dataVals[n+1]):] == dataVals[n+1]):
                    dataVals[n+1]=dataVals[n]
                    continue
                if(dataVals[n+2][len(dataVals[n+2])-len(dataVals[n+1]):]==dataVals[n+1]):
                    dataVals[n+1]=dataVals[n+2]
                    continue
                #Check if the number is equal to it's neighbors beginning
                if dataVals[n+1] == dataVals[n][:len(dataVals[n+1])]:
                    dataVals[n+1]=dataVals[n]
                    continue
                if dataVals[n+1] == dataVals[n+2][:len(dataVals[n+1])]:
                    dataVals[n+1]=dataVals[n+2]
                    continue
                #If none of these are true then it must be a reset so continue.
                else:
                    continue
        dataVals = dataVals.astype(int)
        data["count"] = dataVals
        return data
        
    @staticmethod
    def resetFix(data):
        """Deals with count resets by adding the number before the reset to
        all the following numbers."""
        dataVals = data.iloc[:, 0].to_numpy()
        for n in range(1, len(dataVals)-1):
            #Check if a value is 0 if so => reset
            #if value previous also 0 then adding it does nothing
            if(dataVals[-n-1]==0):
                #Add the previous count to all of the elements after
                dataVals[-n-1:] +=dataVals[-n-2]
        data["count"] = dataVals
        return data
    
        
    @staticmethod
    def missingLineFix(data):
        """Fixes missing lines by adding lines inbetween s.t. there are shorter than
        2 min and 30 seconds intervals between the first and the previously next line."""
        #Convert time to int. (Gives time in ns since 1970)
        dataTS = data.index.astype("int64")
        dataTS = dataTS.to_numpy()
        dataVals = data.iloc[:, 0].to_numpy()
        #Define variable to keep track of size of dataVals (and dataTS) as it increases
        i=0
        #Check if the difference between consecutive times is 150 sec more arbitrarily
        for n in range(len(dataTS)-1):
            if (dataTS[n+i+1]-dataTS[n+i])//10**9 <= 150:
                continue
            #Define an average time and count value
            avgTS = (dataTS[n+i+1]-dataTS[n+i])/(1+(dataTS[n+i+1]-dataTS[n+i])//(150*10**9))
            avgVal = np.floor(dataVals[n+i+1]-dataVals[n+i])/(1+(dataTS[n+i+1]-dataTS[n+i])//(150*10**9))
            #Insert avg time and count value inbetween the 
            #two times which are more than 150 sec apart.
            for k in range(1, ((dataTS[n+i+1]-dataTS[n+i])//(150*10**9))+1):
                print(n)
                dataTS = np.insert(dataTS, n+i+1, dataTS[n+i]+avgTS)
                dataVals = np.insert(dataVals, n+i+1, dataVals[n+i]+avgVal)
                i+=1
        #Resize dataframe to fit in new size collumns.
        data = pd.concat([data, pd.DataFrame([{}]*(len(dataVals)-len(data.index)))], ignore_index=True)
        #Update count collumn
        data["count"] = dataVals
        #Translate dataTS into timestamps in our region
        dataTS = pd.to_datetime(dataTS)
        dataTS=dataTS.tz_localize('UTC')
        dataTS=dataTS.tz_convert('Europe/Stockholm')
        #Update time collumn
        data.index = (dataTS)
        return data
    
    @staticmethod
    def flutterErrorFix(data):
        """Deals with error from birds fluttering by the box by
        limiting counts to approx 8 per 2 minute."""
        dataVals = data.iloc[:, 0].to_numpy()
        for n in range(len(dataVals)-1):
            #Check for more than 8 counts in less than 2 min
            if(dataVals[n+1]-dataVals[n] > 8):
                #Add offset to take care of extra counts and add in 8
                #counts for all elements of index n+1 or higher.
                dataVals[n+1:]+=-(dataVals[n+1]-dataVals[n])+8
        data["count"] = dataVals
        return data
            
    @staticmethod
    def process(data):
        """Calls all functions related to preProcessing for the document and outputs result in a csv file.
        Do not change the order of the calls. Preprocessing may break as
        a result."""
        #Call doubleDateFix before incompleteCount preferably as leads to
        #faster compilation time.
        data=preProcessing.doubleDateFix(data)
        #Call incompleteCountFix before resetFix as resetFix
        #checks for 0 values which may not be resets and could be
        #the end of a glitched number if incompleteCountFix
        #is not called first.
        data=preProcessing.incompleteCountFix(data)
        data=preProcessing.resetFix(data)
        #Missinglinefix can be called anywhere before flutterErrorFix
        #as flutterError fix may take the count difference between dates
        #more than 2 min apart if missingLineFix is not called before
        #Additionally should be called after doubledateFix as missingLineFix
        #checks the difference between consecutive times which can be
        #messed up if double dates (which are out of time order) are not removed.
        data=preProcessing.missingLineFix(data)   
        #flutterErrorFix should be called last as it uses differences between
        #consecutive counts.
        data=preProcessing.flutterErrorFix(data)
        data.to_csv("ProcessedBirdData.csv", sep="\t", encoding="utf-8")
        return data


birds = preProcessing.process(birds)
print(birds)
